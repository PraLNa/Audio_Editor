#                                     Pydub
#
#
# Pydub - это Python-библиотека, котоаря предостовляет удобные инструменты для работы с аудифайлами.
# С помощью этой библиотеки разработчики могут выполнять широкий спектр операций над звуковыми файлами,
# таких как конвертация форматов, нарезка, склеивание, изменение громкости, приминение эффектов и многое другое.
# Pydub облегчает процесс обработки аудиоданных в приложениях, позволяя работать с звуковыми файлами в
# удобном и эффективном программном интерфейсе
#
# Для установки Pydub можно воспользоваться pip, выполнив следующую команду:
#
# "pip install pydub"
#
# Pydub предлагает разнообразные функции, которые делают работу с аудиофайлами более доступной и удобной.
# Эти возможности включают в себя:
#
# Конвертация форматов: Pydub обеспечивает возможность конвертировать аудиофайлы из одного формата в другой без лишних сложностей.
#
# Нарезка и склеивание: с помощью Pydub можно легко вырезать отрезки из аудиофайлов и объединить их вместе,
# что полезно при создании музыкальных композиций или аудиоподкастов.
#
# Изменение громкости: библиотека предоставляет возможность регулировать уровень громкости звуковых файлов,
# что может быть полезно при подготовке звукового контента.
#
# Применение эффектов: Pydub позволяет добавлять различные звуковые эффекты к аудиофайлам,
# что позволяет создавать уникальные звуковые композиции.
#
# Конвертация форматов
# Одним из ключевых возможностей Pydub является возможность конвертировать аудиофайлы из одного формата в другой.
# Это особенно полезно, когда требуется подготовить аудиоданные для определенных устройств или платформ.
#
# С помощью Pydub можно легко выполнить конвертацию форматов, например,
# перевести звуковой файл из MP3 в WAV или обратно.
# Процесс конвертации формата файла занимает всего несколько строк кода благодаря удобному API библиотеки.
#
# Пример конвертации аудиофайла из MP3 в WAV с использованием Pydub:
#
#
# from pydub import AudioSegment
#
# # Загрузка звукового файла в формате MP3
# audio_mp3 = AudioSegment.from_file("input.mp3", format="mp3")
#
# # Конвертация в формат WAV
# audio_wav = audio_mp3.export("output.wav", format="wav")
#
# Таким образом, благодаря функциональности Pydub по конвертации форматов,
# разработчики могут легко адаптировать аудиофайлы под различные требования и нужды проекта.
#
#
# Нарезка и склеивание
# Еще одной полезной возможностью Pydub является возможность нарезки и склеивания аудиофайлов.
# Это позволяет создавать новые звуковые композиции,
# объединяя отрывки из различных звуковых файлов или вырезая нужные фрагменты из исходных записей.
#
# Пример нарезки и склеивания аудиофайлов с использованием Pydub:
#
#
# from pydub import AudioSegment
#
# # Загрузка нескольких звуковых файлов
# audio1 = AudioSegment.from_file("audio1.mp3", format="mp3")
# audio2 = AudioSegment.from_file("audio2.mp3", format="mp3")
#
# # Нарезка аудиофайла
# segment = audio1[:10000]  # Выбор первых 10 секунд
#
# # Склеивание аудиофайлов
# combined = audio1 + audio2
#
# # Экспорт нового файла
# segment.export("segmented_audio.mp3", format="mp3")
# combined.export("combined_audio.mp3", format="mp3")
#
# Изменение громкости
# Одной из важных возможностей Pydub является возможность изменения громкости аудиофайлов.
# Это позволяет контролировать уровень громкости звуковых файлов,
# делая их громче или тише в соответствии с требованиями проекта или предпочтениями пользователя.
#
# Пример изменения громкости аудиофайла с использованием Pydub:
#
#
# from pydub import AudioSegment
#
# # Загрузка звукового файла
# audio = AudioSegment.from_file("input.mp3", format="mp3")
#
# # Изменение громкости (увеличение на 10 децибел)
# louder_audio = audio + 10
#
# # Экспорт файла с измененной громкостью
# louder_audio.export("output.mp3", format="mp3")
#
# В данном примере аудиофайл загружается и к нему применяется операция увеличения громкости на 10 децибел.
# После этого результат сохраняется в новый аудиофайл с измененной громкостью.
#
# Изменение громкости аудиофайлов с помощью Pydub может быть полезным при создании звуковых эффектов,
# нормализации уровня громкости или приведении аудиоданных к определенному стандарту.
#
# Применение эффектов
# Pydub также предоставляет возможность применять различные звуковые эффекты к аудиофайлам.
# Это позволяет добавить к звуковым данным новые звучания,
# изменить тембр или создать уникальные аудиоэффекты для обогащения звука.
#
# Пример применения эффекта увеличения скорости воспроизведения аудиофайла с использованием Pydub:
#
#
# from pydub import AudioSegment
#
# # Загрузка звукового файла
# audio = AudioSegment.from_file("input.mp3", format="mp3")
#
# # Применение эффекта увеличения скорости (ускорение на 1.5 раза)
# sped_up_audio = audio.speedup(playback_speed=1.5)
#
# # Экспорт файла с примененным эффектом
# sped_up_audio.export("sped_up_output.mp3", format="mp3")
#
# В данном примере аудиофайл загружается, к нему применяется эффект увеличения скорости воспроизведения
# (ускорение на 1.5 раза) с помощью метода speedup(),
# после чего результат сохраняется в новый аудиофайл с примененным эффектом.
#
# Применение звуковых эффектов с помощью Pydub позволяет экспериментировать с звуковыми данными,
# создавать уникальные звуковые композиции или подготавливать аудиофайлы для различных целей.
#
#
#
#                            Simpleaudio
#
#
# Simpleaudio - это простой Python-модуль для асинхронного воспроизведения звука.
# Он не требует внешних зависимостей и работает на различных операционных системах, включая macOS,
# Windows и Linux. Установить его можно с помощью pip:
#
# "pip install simpleaudio"
#
# Для воспроизведения звука необходимо загрузить аудиофайл и использовать функцию play_buffer или play_wave
#
# Основные функции:
#
# WaveObject.from_wave_file(filename): Загружает WAV-файл.
#
# WaveObject.play(): Начинает воспроизведение.
#
# play_obj.wait_done(): Блокирует программу до окончания воспроизведения.
#
# simpleaudio.play_buffer(audio_data, num_channels, bytes_per_sample, sample_rate):
# Воспроизводит данные, переданные в формате audio_data.
#
# simpleaudio.stop_all(): Останавливает все текущие воспроизведения.
#
# Дополнительные возможности:
#
# Можно загружать данные из буфера (например, сгенерированные в коде).
#
# Можно управлять воспроизведением (пауза, возобновление, остановка).
#
# Можно настраивать параметры звука, такие как частота дискретизации и количество каналов.
#
#
# Модуль реализует асинхронный интерфейс, что означает,
# что выполнение программы продолжается сразу после начала воспроизведения звука,
# а фоновый поток берёт на себя всё остальное.
# Это упрощает встраивание воспроизведения звука в графические приложения, требующие высокой отзывчивости.
# Это также означает, что приложения для работы со звуком в реальном времени (например, синтезаторы)
# невозможны, поскольку весь воспроизводимый аудиоклип должен быть готов к воспроизведению.
#
# Simpleaudio поддерживает стандартные целочисленные 8-, 16- и 24-битные форматы целых чисел,
# а также 32-битные форматы с плавающей запятой. 8-битные форматы — беззнаковые.
# 16-битные и 24-битные форматы — знаковые с прямым порядком байтов.
# 24-битные форматы — это три байта на упакованный сэмпл, т. е. каждый сэмпл — это три байта,
# за которыми сразу следует следующий трехбайтовый сэмпл,
# без какого-либо байта заполнения для выравнивания по границе 4-байтового слова.
# 32-битные форматы — это с плавающей запятой с прямым порядком байтов.
#
# Поддерживается моно (1-канальный) и стерео (2-канальный) звук.
#
# Допустимы следующие частоты дискретизации (хотя поддержка вашей платформы/оборудования не гарантируется):
# 8, 11,025, 16, 22,05, 32, 44,1, 48, 88,2, 96 и 192 кГц.
#
# Сравнение с PyAudioPython
# PyAudio — это библиотека, предоставляющая возможности для работы с аудио в языке программирования Python.
# Она позволяет осуществлять запись и воспроизведение звука, работать с аудиоданными в реальном времени,
# обрабатывать звуковые потоки и многое другое.
#
# PyAudio — ещё одна кроссплатформенная аудиобиблиотека для Python.
# Хотя она обладает более широкими возможностями, чем simpleaudio,
# такими как запись и непрерывная потоковая передача звука, её работа зависит от наличия PortAudio ,
# что усложняет установку.
# Simpleaudio задуман как универсальный кроссплатформенный аудиоинтерфейс для воспроизведения аудиоклипов.
#
#
#
# Модуль audioSegment
#
# Этот модуль просто предостовляет оболочку объекта pydub.AudioSegment
# Этот класс является оболочкой для pydub.AudioSegment, которая предоставляет дополнительные методы.
#
#
# Возвращает список объектов AudioSegment, каждый из которых содержит все звуки,
# воспроизводимые в течение этого AudioSegment из определённого источника.
# То есть, если в этом AudioSegment есть несколько перекрывающихся звуков, этот метод вернёт один объект AudioSegment для каждого из этих звуков. По крайней мере, такова идея.
#
# Текущая версия находится на стадии альфа-тестирования, и хотя она выглядит многообещающе,
# потребуется еще немало доработок, прежде чем ее можно будет заявить о ее действительной работоспособности.
#
#
# Параметры:
#
# debug – если True , выводит отладочную информацию по ходу выполнения.
# Полезно, если хотите понять, почему процесс занимает так много времени.
# debugplot – если True, будет использоваться Matplotlib для построения результирующих масок
# спектрограмм в шкале частот Mel.
#
# Возврат:
# Список объектов AudioSegment, каждый из которых относится к определенному источнику звука.
#
#
# Возвращается список кортежей вида [('n', AudioSegment), ('y', AudioSegment) и т. д.],
# где кортежи вида ('n', AudioSegment) — это сегменты звука, где событие не было обнаружено,
# а кортежи вида ('y', AudioSegment) — это сегменты звука, где событие было обнаружено.
#
#
#
#
# import audiosegment
# import keras
# import keras.models
# import numpy as np
# import sys
#
# class Model:
#     def __init__(self, modelpath):
#         self.model = keras.models.load_model(modelpath)
#
#     def predict(self, seg):
#         _bins, fft_vals = seg.fft()
#         fft_vals = np.abs(fft_vals) / len(fft_vals)
#         predicted_np_form = self.model.predict(np.array([fft_vals]), batch_size=1)
#         prediction_as_int = int(round(predicted_np_form[0][0]))
#         return prediction_as_int
#
# modelpath = sys.argv[1]
# wavpath = sys.argv[2]
# model = Model(modelpath)
# seg = audiosegment.from_file(wavpath).resample(sample_rate_Hz=32000, sample_width=2, channels=1)
# pyes_to_no = 0.3  # The probability of one 30 ms sample being an event, and the next one not
# pno_to_yes = 0.2  # The probability of one 30 ms sample not being an event, and the next one yes
# ptrue_pos_rate = 0.8  # The true positive rate (probability of a predicted yes being right)
# pfalse_neg_rate = 0.3  # The false negative rate (probability of a predicted no being wrong)
# raw_prob = 0.7  # The raw probability of seeing the event in any random 30 ms slice of this file
# events = seg.detect_event(model, ms_per_input=30, transition_matrix=[pyes_to_no, pno_to_yes],
#                           model_stats=[ptrue_pos_rate, pfalse_neg_rate], event_length_s=0.25,
#                           prob_raw_yes=raw_prob)
# nos = [event[1] for event in events if event[0] == 'n']
# yeses = [event[1] for event in events if event[0] == 'y']
# if len(nos) > 1:
#     notdetected = nos[0].reduce(nos[1:])
#     notdetected.export("notdetected.wav", format="WAV")
# if len(yeses) > 1:
#     detected = yeses[0].reduce(yeses[1:])
#     detected.export("detected.wav", format="WAV")
#
#
# Параметры:
#
# model – Модель. Модель должна иметь функцию predict(),
# которая принимает AudioSegment с заданным числом ms_per_input в миллисекундах и возвращает 1,
# если аудиособытие обнаружено на этом входе, и 0, если нет. Перед вызовом этой функции убедитесь,
# что AudioSegment ресэмплирован до правильных значений.
#
# ms_per_input – количество мс AudioSegment, передаваемых в модель за один раз. Если это число нечётное,
# последний AudioSegment будет дополнен нулями.
#
# transition_matrix – итерируемая матрица вида: [p(да->нет), p(нет->да)],
# то есть вероятность перехода из состояния «да» в состояние «нет» и вероятность обратного перехода.
#
# model_stats – итерируемая переменная вида: [p(реальность=1|выход=1), p(реальность=1|выход=0)].
# То есть вероятность того, что истинное значение действительно равно 1, при условии,
# что модель выдала 1, и вероятность того, что истинное значение равно 1, при условии, что модель выдала 0.
#
# event_length_s – Типичная продолжительность события, которое вы ищете, в секундах
# (может быть числом с плавающей точкой).
#
# start_as_yes — если True, первый элемент ms_per_input будет относиться к категории «y».
# В противном случае он будет относиться к категории «n».
#
# prob_raw_yes – сырая вероятность нахождения события в любом заданном векторе ms_per_input .
#
# Возврат:
#
# Список кортежей вида [('n', AudioSegment), ('y', AudioSegment) и т. д.],
# где на протяжении списка AudioSegment в кортеже 3 продолжается с того места,
# где остановился AudioSegment в кортеже 2.
#
#

# В музыке сэмпл (sample) - это небольшой фрагмент звуковой записи,
# который используется в качестве строительного блока для создания новой музыки.
# Это может быть фрагмент песни, звука, шума или любого другого аудио,
# который был оцифрован и затем использован в новой композиции.
# Сэмплирование - это процесс использования таких семплов в создании новой музыки.